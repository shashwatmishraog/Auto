# -*- coding: utf-8 -*-
"""cuGraph.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KM6XD_YO7A6lz1hA-zfohlaU_tK-UOS8
"""

!pip install nx-arangodb

!nvidia-smi
!nvcc --version

!pip install nx-cugraph-cu12 --extra-index-url https://pypi.nvidia.com # Requires CUDA-capable GPU

!pip install --upgrade langchain langchain-community langchain-openai langgraph

import networkx as nx
import nx_arangodb

from arango import ArangoClient

import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from random import randint
import re

from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import MemorySaver
from langchain_openai import ChatOpenAI
from langchain_community.graphs import ArangoGraph
from langchain_community.chains.graph_qa.arangodb import ArangoGraphQAChain
from langchain_core.tools import tool

!pip install phenolrs

"""**Setup Database**"""

from arango import ArangoClient
import base64

encodedCA = "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURHVENDQWdHZ0F3SUJBZ0lSQU5HNjZjclREM3RyTEtRcTc3QVkvam93RFFZSktvWklodmNOQVFFTEJRQXcKSmpFUk1BOEdBMVVFQ2hNSVFYSmhibWR2UkVJeEVUQVBCZ05WQkFNVENFRnlZVzVuYjBSQ01CNFhEVEkxTURNdwpPVEV3TVRreU1Wb1hEVE13TURNd09ERXdNVGt5TVZvd0pqRVJNQThHQTFVRUNoTUlRWEpoYm1kdlJFSXhFVEFQCkJnTlZCQU1UQ0VGeVlXNW5iMFJDTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUEKdVlEd09oQ25Sa2JoM0VSRUVMNEgyQy9CVkFLb0poM29sMTJsNlpNbzJNUDF3ck13bExocTNudkQxVFg1dHpWQQpxOXczckMrMEJCc1lzU2Z0WWlXdFE3dkZZSHZMY3VVVkJPOVJRSXZSRVZZMXhhM2ltbG9yMXIwM3JGa2M3U21xClgySkE5T3laV2l2Q0F2Z2JLUVJOWWV4ZUdvVVRWbkY0cTdXNjg2OUczQi9sSm01TitDb1luYW93WHIrNVJrd2QKTDNJc2VZNTJZaUdHVHVjVDFMYitSVW96a2wvMDgzQmFjQVFPb0VXemtUS3A0K0o1YW52OXZFSTdId25iaElRYQpVYURlQWdhbmxKaW5kblJMckJxTHZ1UHg0VUR0eXVsOENvZ04yM0ZpSzdQT0xuOWxXZEpBRTQyNy9peDFnOUprCktLS2lIVHhHZERoaWM0RWtVaGx1alFJREFRQUJvMEl3UURBT0JnTlZIUThCQWY4RUJBTUNBcVF3RHdZRFZSMFQKQVFIL0JBVXdBd0VCL3pBZEJnTlZIUTRFRmdRVVdPMUE2aDhCWGtrMndXelpjUGVQWDlSSjU5TXdEUVlKS29aSQpodmNOQVFFTEJRQURnZ0VCQUxqU2VmeldPaDhaVng2bnA3TGF6ZFQ4Y0VrUlRuT1Y5WmpOaUhsYVRHOGd6UzhGCmFidmtob0tnN2FJSFRoTG9ubVBzYmhPVFA2N1g2UCs4aEtseWF4QmgvNk5QZ2o2Q01LbkczTCtXeEF4ZUdVQkkKSVk4dDRWVmZ3aVZlSnFJSnI1MWN1QmpxVy9CYjJJMHB5azBkNjVhWGZpU2RrWE05OFhOUVc1aG5wOWNhWmo1WgpoWWZhNnhzeGlqcFFEQnNudytTNEJLSXRKcjhZYlR6QzVXN2dMU2ZCcUdWVk5tVlE1WWVCQlVxTkdsVkFTclIrCjJIdE5UOEFaOGlqaG9udXhPRElZMVBLS2pJejdUd044U3dGVXQ2OEp3VStPcE9ZWGxDZ0tsK0RYUjJlTVlmN0YKencvSDF1UjlpS2YwcGc2c0prYmhSQnR0cG5VajdCZ2wvci9GR3VBPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg=="
try:
    file_content = base64.b64decode(encodedCA)
    with open("cert_file.crt", "w+") as f:
        f.write(file_content.decode("utf-8"))
except Exception as e:
    print(str(e))
    exit(1)

client = ArangoClient(
    hosts="https://a23773dce0fa.arangodb.cloud:18529", verify_override="cert_file.crt"
)

sys_db = client.db("_system", username="root", password="Sw3LjtHlZTIjNPPBfkIP")

# Note that ArangoGraph Insights Platform runs deployments in a cluster configuration.
# To achieve the best possible availability, your client application has to handle
# connection failures by retrying operations if needed.
print("ArangoDB:", sys_db.version())

!pip install arango_datasets

from arango_datasets import Datasets
datasets = Datasets(sys_db)

# List datasets
print(datasets.list_datasets())
print(datasets.dataset_info("CVE"))

G = datasets.load("CVE")

import nx_arangodb as nxadb
G_adb = nxadb.Graph(name="CVE", db=sys_db)

arango_graph = ArangoGraph(sys_db)

!pip install langchain-groq

!pip install python3-nmap
!sudo apt-get install nmap

# prompt: nmap --version

import subprocess

def get_nmap_version():
  try:
    result = subprocess.run(['nmap', '--version'], capture_output=True, text=True, check=True)
    return result.stdout.strip()
  except FileNotFoundError:
    return "nmap not found. Please install nmap."
  except subprocess.CalledProcessError as e:
    return f"Error running nmap: {e}"

print(get_nmap_version())

import nmap3
import re

@tool
def return_nmap_scan(query: str):
    """
    This tool extracts an IP address from the query, performs an Nmap version scan,
    and fetches known vulnerabilities from the ArangoDB dataset.
    """
    # Extract the IP address from the query
    ip_match = re.search(r"\b(?:\d{1,3}\.){3}\d{1,3}\b", query)
    if not ip_match:
        return "Could not find a valid IP address in the query."

    ip_address = ip_match.group(0)

    # Perform Nmap version scan
    nmap = nmap3.Nmap()
    scan_results = nmap.nmap_version_detection(ip_address)

    if not scan_results or ip_address not in scan_results:
        return f"No scan results found for {ip_address}."

    # Extract detected services and versions
    detected_services = []
    for port, details in scan_results[ip_address].items():
        service_name = details.get("service", "")
        version = details.get("version", "")
        if service_name:
            detected_services.append((service_name, version))

    if not detected_services:
        return f"Nmap scan completed, but no detectable services were found on {ip_address}."

    # Query ArangoDB for vulnerabilities
    vulnerabilities = []
    for service, version in detected_services:
        if version:
            query = f"""
                Retrieve all known vulnerabilities (CVEs) related to the service '{service}'
                with version '{version}' from the ArangoDB graph.
                Return critical details such as CVE IDs, severity, and descriptions.
            """
        else:
            query = f"""
                Retrieve all known vulnerabilities (CVEs) related to the service '{service}'
                from the ArangoDB graph. Return critical details such as CVE IDs, severity,
                and descriptions.
            """

        vuln_data = text_to_aql_to_text(query)  # Fetch from ArangoDB
        if vuln_data and vuln_data != "No results found":
            vulnerabilities.append({service: vuln_data})

    # Format the response
    if vulnerabilities:
        return {
            "ip_address": ip_address,
            "detected_services": detected_services,
            "vulnerabilities": vulnerabilities
        }
    else:
        return f"No known vulnerabilities found for detected services on {ip_address}."

@tool
def text_to_aql_to_text(query: str):
    """This tool translates a Natural Language Query into AQL, executes
    the query, and translates the result back into Natural Language.
    """

    GROQ_API_KEY = userdata.get('GROQ_API_KEY')
    llm = ChatGroq(temperature=0, groq_api_key=GROQ_API_KEY, model="llama-3.3-70b-versatile")
    chain = ArangoGraphQAChain.from_llm(
    	llm=llm,
    	graph=arango_graph,
    	verbose=True,
        allow_dangerous_requests=True
    )

    result = chain.invoke(query)

    if "result" in result and result["result"]:
        return str(result["result"])
    else:
        return "No results found"

@tool
def text_to_nx_algorithm_to_text(query):
    """This tool runs a NetworkX algorithm on an ArangoDB Graph and
    translates the results back into Natural Language.
    """
    GROQ_API_KEY = userdata.get('GROQ_API_KEY')
    llm = ChatGroq(temperature=0, groq_api_key=GROQ_API_KEY, model="llama-3.3-70b-versatile")

    print("1) Generating NetworkX code")

    text_to_nx = llm.invoke(f"""
    I have a NetworkX Graph called `G_adb`. It has the following schema: {arango_graph.schema}

    My query is: {query}.

    Generate the Python Code required to answer the query using `G_adb`.

    Ensure that:
    - The correct NetworkX algorithm is used.
    - The code is precise and efficient.
    - The final result is stored in a variable named `FINAL_RESULT`.
    - `FINAL_RESULT` should be short and concise.

    Provide only the Python code, without explanations.

    Your code:
    """).content

    text_to_nx_cleaned = re.sub(r"^```python\n|```$", "", text_to_nx, flags=re.MULTILINE).strip()

    print('-'*10)
    print(text_to_nx_cleaned)
    print('-'*10)

    print("\n2) Executing NetworkX code")
    global_vars = {"G_adb": G_adb, "nx": nx}
    local_vars = {}

    try:
        exec(text_to_nx_cleaned, global_vars, local_vars)
        text_to_nx_final = text_to_nx
    except Exception as e:
        print(f"EXEC ERROR: {e}")
        return f"EXEC ERROR: {e}"

    FINAL_RESULT = local_vars["FINAL_RESULT"]
    print('-'*10)
    print(f"FINAL_RESULT: {FINAL_RESULT}")
    print('-'*10)

    print("3) Formulating final answer")

    nx_to_text = llm.invoke(f"""
        I have executed a NetworkX algorithm to answer the following query:

        {query}

        The result, stored in `FINAL_RESULT`, is: {FINAL_RESULT}.

        Generate a short and clear explanation of the result.

        Your response:
    """).content

    return nx_to_text

tools = [text_to_aql_to_text, text_to_nx_algorithm_to_text, return_nmap_scan]

def query_graph(query):
    GROQ_API_KEY = userdata.get('GROQ_API_KEY')
    llm = ChatGroq(temperature=0, groq_api_key=GROQ_API_KEY, model="llama-3.3-70b-versatile")
    app = create_react_agent(llm, tools)
    final_state = app.invoke({"messages": [{"role": "user", "content": query}]})
    return final_state["messages"][-1].content

query_graph("Scan 44.228.249.3 for vulnerabilities")

"""
Vulnerability Scanner using ArangoDB CVE dataset and Nmap
This script connects to ArangoDB, loads CVE data, and provides tools for scanning IP addresses.
"""

# Separate the installation commands
# These should be run separately before executing the script
# !pip install nx-arangodb nx-cugraph-cu12 --extra-index-url https://pypi.nvidia.com
# !pip install --upgrade langchain langchain-community langchain-openai langgraph
# !pip install phenolrs arango_datasets langchain-groq python3-nmap

import os
import re
import base64
import subprocess
from typing import Dict, List, Optional, Any, Union

# Core imports
import networkx as nx
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# ArangoDB imports
from arango import ArangoClient
import nx_arangodb as nxadb
from arango_datasets import Datasets

# LangChain imports
from langgraph.prebuilt import create_react_agent
from langgraph.checkpoint.memory import MemorySaver
from langchain_openai import ChatOpenAI
from langchain_community.graphs import ArangoGraph
from langchain_community.chains.graph_qa.arangodb import ArangoGraphQAChain
from langchain_core.tools import tool
from langchain_groq import ChatGroq

# Nmap imports (with error handling)
try:
    import nmap3
    NMAP_AVAILABLE = True
except ImportError:
    print("Warning: nmap3 module not available. Nmap scanning will be disabled.")
    NMAP_AVAILABLE = False

# Function to securely get credentials
def get_credentials() -> Dict[str, str]:
    """Get credentials from environment variables or prompt user."""
    credentials = {
        "arangodb_host": os.getenv("ARANGODB_HOST", "https://a23773dce0fa.arangodb.cloud:18529"),
        "arangodb_user": os.getenv("ARANGODB_USER", "root"),
        "arangodb_password": os.getenv("ARANGODB_PASSWORD", None),
        "groq_api_key": os.getenv("GROQ_API_KEY", None)
    }

    # Prompt for missing credentials
    for key, value in credentials.items():
        if value is None:
            import getpass
            credentials[key] = getpass.getpass(f"Enter {key}: ")

    return credentials

def setup_arangodb(credentials: Dict[str, str]) -> tuple:
    """Setup ArangoDB connection and load CVE dataset."""
    # Setup SSL certificate for ArangoDB
    encodedCA = "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURHVENDQWdHZ0F3SUJBZ0lSQU5HNjZjclREM3RyTEtRcTc3QVkvam93RFFZSktvWklodmNOQVFFTEJRQXcKSmpFUk1BOEdBMVVFQ2hNSVFYSmhibWR2UkVJeEVUQVBCZ05WQkFNVENFRnlZVzVuYjBSQ01CNFhEVEkxTURNdwpPVEV3TVRreU1Wb1hEVE13TURNd09ERXdNVGt5TVZvd0pqRVJNQThHQTFVRUNoTUlRWEpoYm1kdlJFSXhFVEFQCkJnTlZCQU1UQ0VGeVlXNW5iMFJDTUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUEKdVlEd09oQ25Sa2JoM0VSRUVMNEgyQy9CVkFLb0poM29sMTJsNlpNbzJNUDF3ck13bExocTNudkQxVFg1dHpWQQpxOXczckMrMEJCc1lzU2Z0WWlXdFE3dkZZSHZMY3VVVkJPOVJRSXZSRVZZMXhhM2ltbG9yMXIwM3JGa2M3U21xClgySkE5T3laV2l2Q0F2Z2JLUVJOWWV4ZUdvVVRWbkY0cTdXNjg2OUczQi9sSm01TitDb1luYW93WHIrNVJrd2QKTDNJc2VZNTJZaUdHVHVjVDFMYitSVW96a2wvMDgzQmFjQVFPb0VXemtUS3A0K0o1YW52OXZFSTdId25iaElRYQpVYURlQWdhbmxKaW5kblJMckJxTHZ1UHg0VUR0eXVsOENvZ04yM0ZpSzdQT0xuOWxXZEpBRTQyNy9peDFnOUprCktLS2lIVHhHZERoaWM0RWtVaGx1alFJREFRQUJvMEl3UURBT0JnTlZIUThCQWY4RUJBTUNBcVF3RHdZRFZSMFQKQVFIL0JBVXdBd0VCL3pBZEJnTlZIUTRFRmdRVVdPMUE2aDhCWGtrMndXelpjUGVQWDlSSjU5TXdEUVlKS29aSQpodmNOQVFFTEJRQURnZ0VCQUxqU2VmeldPaDhaVng2bnA3TGF6ZFQ4Y0VrUlRuT1Y5WmpOaUhsYVRHOGd6UzhGCmFidmtob0tnN2FJSFRoTG9ubVBzYmhPVFA2N1g2UCs4aEtseWF4QmgvNk5QZ2o2Q01LbkczTCtXeEF4ZUdVQkkKSVk4dDRWVmZ3aVZlSnFJSnI1MWN1QmpxVy9CYjJJMHB5azBkNjVhWGZpU2RrWE05OFhOUVc1aG5wOWNhWmo1WgpoWWZhNnhzeGlqcFFEQnNudytTNEJLSXRKcjhZYlR6QzVXN2dMU2ZCcUdWVk5tVlE1WWVCQlVxTkdsVkFTclIrCjJIdE5UOEFaOGlqaG9udXhPRElZMVBLS2pJejdUd044U3dGVXQ2OEp3VStPcE9ZWGxDZ0tsK0RYUjJlTVlmN0YKencvSDF1UjlpS2YwcGc2c0prYmhSQnR0cG5VajdCZ2wvci9GR3VBPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg=="

    try:
        file_content = base64.b64decode(encodedCA)
        with open("cert_file.crt", "w+") as f:
            f.write(file_content.decode("utf-8"))
    except Exception as e:
        print(f"Error setting up SSL certificate: {str(e)}")
        raise

    # Connect to ArangoDB
    client = ArangoClient(
        hosts=credentials["arangodb_host"],
        verify_override="cert_file.crt"
    )

    try:
        sys_db = client.db(
            "_system",
            username=credentials["arangodb_user"],
            password=credentials["arangodb_password"]
        )
        print(f"ArangoDB: {sys_db.version()}")

        # Load CVE dataset
        datasets = Datasets(sys_db)
        print(f"Available datasets: {datasets.list_datasets()}")

        # Load the CVE dataset
        G = datasets.load("CVE")
        G_adb = nxadb.Graph(name="CVE", db=sys_db)
        arango_graph = ArangoGraph(sys_db)

        return sys_db, G, G_adb, arango_graph

    except Exception as e:
        print(f"Error connecting to ArangoDB: {str(e)}")
        raise

def get_nmap_version() -> str:
    """Get Nmap version information."""
    if not NMAP_AVAILABLE:
        return "Nmap not available. Please install nmap3 module."

    try:
        result = subprocess.run(['nmap', '--version'], capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except FileNotFoundError:
        return "Nmap executable not found. Please install nmap."
    except subprocess.CalledProcessError as e:
        return f"Error running nmap: {e}"

@tool
def return_nmap_scan(query: str, arango_graph=None, text_to_aql_to_text_fn=None) -> Union[Dict[str, Any], str]:
    """
    Extract an IP address from the query, perform an Nmap version scan,
    and fetch known vulnerabilities from the ArangoDB dataset.

    Args:
        query: A string containing an IP address to scan
        arango_graph: ArangoGraph instance
        text_to_aql_to_text_fn: Function to query ArangoDB

    Returns:
        Dict containing scan results and vulnerabilities or error message
    """
    if not NMAP_AVAILABLE:
        return "Nmap functionality is not available. Please install the nmap3 module."

    # Extract the IP address from the query
    ip_match = re.search(r"\b(?:\d{1,3}\.){3}\d{1,3}\b", query)
    if not ip_match:
        return "Could not find a valid IP address in the query."

    ip_address = ip_match.group(0)
    print(f"Starting Nmap scan on {ip_address}...")

    try:
        # Perform Nmap version scan with timeout
        nmap = nmap3.Nmap()
        scan_results = nmap.nmap_version_detection(ip_address, args="-T4 --max-retries 1 --host-timeout 30s")

        if not scan_results or ip_address not in scan_results:
            return f"No scan results found for {ip_address}."

        # Extract detected services and versions
        detected_services = []
        for port, details in scan_results[ip_address].items():
            if isinstance(details, dict) and port != "osmatch" and port != "ports" and port != "hostname":  # Ensure details is a dictionary
                service_name = details.get("service", {}).get("name", "") if isinstance(details.get("service"), dict) else details.get("service", "")
                version = details.get("service", {}).get("product", "") if isinstance(details.get("service"), dict) else details.get("version", "")
                if service_name:
                    detected_services.append((service_name, version))

        print(f"Detected services: {detected_services}")

        if not detected_services:
            return f"Nmap scan completed, but no detectable services were found on {ip_address}."

        # For direct response without database query if function not available
        if not text_to_aql_to_text_fn or not arango_graph:
            return {
                "ip_address": ip_address,
                "detected_services": detected_services,
                "note": "Vulnerability data not available as database connection is not configured"
            }

        # Query ArangoDB for vulnerabilities
        vulnerabilities = []
        for service, version in detected_services:
            if version:
                query = f"""
                    Find vulnerabilities (CVEs) for the service '{service}'
                    version '{version}' in the ArangoDB graph.
                    Return only critical and high severity vulnerabilities.
                """
            else:
                query = f"""
                    Find vulnerabilities (CVEs) for the service '{service}'
                    in the ArangoDB graph. Return only critical and high
                    severity vulnerabilities.
                """

            try:
                vuln_data = text_to_aql_to_text_fn(query)
                if vuln_data and vuln_data != "No results found":
                    vulnerabilities.append({service: vuln_data})
            except Exception as e:
                print(f"Error querying vulnerabilities for {service}: {str(e)}")
                # Continue with other services even if one fails

        # Format the response
        if vulnerabilities:
            return {
                "ip_address": ip_address,
                "detected_services": detected_services,
                "vulnerabilities": vulnerabilities
            }
        else:
            return f"Scan completed. Detected services on {ip_address}: {detected_services}. No known critical or high severity vulnerabilities found."

    except Exception as e:
        error_msg = str(e)
        print(f"Error during Nmap scan: {error_msg}")
        return f"Error during nmap scan of {ip_address}: {error_msg}"

@tool
def text_to_aql_to_text(query: str, arango_graph=None, groq_api_key=None) -> str:
    """
    Translate a Natural Language Query into AQL, execute the query,
    and translate the result back into Natural Language.

    Args:
        query: Natural language query string
        arango_graph: ArangoGraph instance
        groq_api_key: API key for Groq

    Returns:
        String containing the query results or error message
    """
    if not arango_graph:
        return "ArangoDB graph is not available."

    if not groq_api_key:
        return "Groq API key is required but not provided."

    try:
        llm = ChatGroq(temperature=0, groq_api_key=groq_api_key, model="llama-3.3-70b-versatile")
        chain = ArangoGraphQAChain.from_llm(
            llm=llm,
            graph=arango_graph,
            verbose=True,
            allow_dangerous_requests=True
        )

        result = chain.invoke(query)

        if "result" in result and result["result"]:
            return str(result["result"])
        else:
            return "No results found"
    except Exception as e:
        return f"Error querying ArangoDB: {str(e)}"

@tool
def text_to_nx_algorithm_to_text(query: str, G_adb=None, arango_graph=None, groq_api_key=None) -> str:
    """
    Run a NetworkX algorithm on an ArangoDB Graph and
    translate the results back into Natural Language.

    Args:
        query: Natural language query string
        G_adb: NetworkX graph from ArangoDB
        arango_graph: ArangoGraph instance
        groq_api_key: API key for Groq

    Returns:
        String containing the algorithm results or error message
    """
    if not G_adb:
        return "NetworkX graph is not available."

    if not arango_graph:
        return "ArangoDB graph is not available."

    if not groq_api_key:
        return "Groq API key is required but not provided."

    try:
        llm = ChatGroq(temperature=0, groq_api_key=groq_api_key, model="llama-3.3-70b-versatile")

        print("1) Generating NetworkX code")

        text_to_nx = llm.invoke(f"""
        I have a NetworkX Graph called `G_adb`. It has the following schema: {arango_graph.schema}

        My query is: {query}.

        Generate the Python Code required to answer the query using `G_adb`.

        Ensure that:
        - The correct NetworkX algorithm is used.
        - The code is precise and efficient.
        - The final result is stored in a variable named `FINAL_RESULT`.
        - `FINAL_RESULT` should be short and concise.

        Provide only the Python code, without explanations.

        Your code:
        """).content

        text_to_nx_cleaned = re.sub(r"^```python\n|```$", "", text_to_nx, flags=re.MULTILINE).strip()

        print('-'*10)
        print(text_to_nx_cleaned)
        print('-'*10)

        print("\n2) Executing NetworkX code")
        global_vars = {"G_adb": G_adb, "nx": nx}
        local_vars = {}

        exec(text_to_nx_cleaned, global_vars, local_vars)

        if "FINAL_RESULT" not in local_vars:
            return "Error: The generated code did not produce a FINAL_RESULT variable."

        FINAL_RESULT = local_vars["FINAL_RESULT"]
        print('-'*10)
        print(f"FINAL_RESULT: {FINAL_RESULT}")
        print('-'*10)

        print("3) Formulating final answer")

        nx_to_text = llm.invoke(f"""
            I have executed a NetworkX algorithm to answer the following query:

            {query}

            The result, stored in `FINAL_RESULT`, is: {FINAL_RESULT}.

            Generate a short and clear explanation of the result.

            Your response:
        """).content

        return nx_to_text

    except Exception as e:
        return f"Error executing NetworkX algorithm: {str(e)}"

def create_tools(arango_graph, G_adb, groq_api_key):
    """Create tools with the necessary dependencies injected."""
    import functools
    from langchain_core.tools import tool

    # Create a direct scan function that doesn't rely on tool decoration
    def direct_nmap_scan(query):
        """Run Nmap scan directly without LangChain tool wrapper"""
        if not NMAP_AVAILABLE:
            return "Nmap functionality is not available. Please install the nmap3 module."

        # Extract the IP address from the query
        ip_match = re.search(r"\b(?:\d{1,3}\.){3}\d{1,3}\b", query)
        if not ip_match:
            return "Could not find a valid IP address in the query."

        ip_address = ip_match.group(0)
        print(f"Starting Nmap scan on {ip_address}...")

        try:
            # Perform Nmap version scan with timeout
            nmap = nmap3.Nmap()
            scan_results = nmap.nmap_version_detection(ip_address, args="-T4 --max-retries 1 --host-timeout 30s")

            if not scan_results or ip_address not in scan_results:
                return f"No scan results found for {ip_address}."

            # Extract detected services and versions
            detected_services = []
            for port, details in scan_results[ip_address].items():
                if isinstance(details, dict) and port != "osmatch" and port != "ports" and port != "hostname":
                    if "service" in details:
                        if isinstance(details["service"], dict):
                            service_name = details["service"].get("name", "")
                            version = details["service"].get("product", "")
                        else:
                            service_name = details["service"]
                            version = details.get("version", "")

                        if service_name:
                            detected_services.append((service_name, version))

            print(f"Detected services: {detected_services}")

            if not detected_services:
                return f"Nmap scan completed, but no detectable services were found on {ip_address}."

            # Simple response for direct execution
            services_str = "\n".join([f"- {service} {version}" for service, version in detected_services])
            return f"""
Scan completed for {ip_address}

Detected services:
{services_str}

Note: To get vulnerability information, please use the agent with a query like
"What vulnerabilities are associated with the services on {ip_address}?"
"""

        except Exception as e:
            import traceback
            print(f"Error during Nmap scan: {traceback.format_exc()}")
            return f"Error during nmap scan of {ip_address}: {str(e)}"

    # Create wrapper functions with proper docstring preservation
    @tool
    def text_to_aql_wrapper(query: str):
        """
        Translate a Natural Language Query into AQL, execute the query,
        and translate the result back into Natural Language.
        """
        return text_to_aql_to_text(query, arango_graph, groq_api_key)

    @tool
    def text_to_nx_wrapper(query: str):
        """
        Run a NetworkX algorithm on an ArangoDB Graph and
        translate the results back into Natural Language.
        """
        return text_to_nx_algorithm_to_text(query, G_adb, arango_graph, groq_api_key)

    @tool
    def nmap_scan_wrapper(query: str):
        """
        Extract an IP address from the query, perform an Nmap version scan,
        and fetch known vulnerabilities from the ArangoDB dataset.
        """
        return direct_nmap_scan(query)

    return [text_to_aql_wrapper, text_to_nx_wrapper, nmap_scan_wrapper]

def query_graph(query: str, credentials: Dict[str, str], sys_db=None, G=None, G_adb=None, arango_graph=None):
    """
    Create a LangGraph agent with tools and query the graph.

    Args:
        query: Query string
        credentials: Dictionary containing API keys
        sys_db: ArangoDB system database
        G: Graph
        G_adb: NetworkX graph from ArangoDB
        arango_graph: ArangoGraph instance

    Returns:
        Agent response
    """
    # Setup ArangoDB if not provided
    if not all([sys_db, G, G_adb, arango_graph]):
        sys_db, G, G_adb, arango_graph = setup_arangodb(credentials)

    # Create tools with dependencies injected
    tools = create_tools(arango_graph, G_adb, credentials["groq_api_key"])

    # Process URL queries
    if query.startswith('http'):
        # Extract domain from URL
        import re
        domain_match = re.search(r'https?://([^/]+)', query)
        if domain_match:
            domain = domain_match.group(1)
            # Use nslookup to get IP address
            try:
                import socket
                ip_address = socket.gethostbyname(domain)
                print(f"Resolved {domain} to IP: {ip_address}")
                query = f"Scan {ip_address} for vulnerabilities"
            except socket.gaierror:
                return f"Could not resolve domain {domain} to an IP address. Please provide a valid IP address instead."

    # Special case for direct tool execution
    if query.startswith("Scan "):
        ip_match = re.search(r"\b(?:\d{1,3}\.){3}\d{1,3}\b", query)
        if ip_match:
            print(f"Performing direct scan on IP: {ip_match.group(0)}")
            # Instead of using the tool directly, run the scan function
            try:
                # Get the wrapper functions from create_tools
                nmap_wrapper = tools[2]

                # Use the direct function call instead of invoke
                result = nmap_wrapper.func(query)
                return f"Scan results for {ip_match.group(0)}:\n\n{result}"
            except Exception as e:
                import traceback
                print(f"Error during scan: {traceback.format_exc()}")
                return f"Error scanning IP {ip_match.group(0)}: {str(e)}"

    # Create LangGraph agent with increased recursion limit
    from langgraph.prebuilt import create_react_agent

    llm = ChatGroq(
        temperature=0,
        groq_api_key=credentials["groq_api_key"],
        model="llama-3.3-70b-versatile"
    )

    # Configure the agent with increased recursion limit
    config = {"recursion_limit": 50}
    app = create_react_agent(llm, tools)

    try:
        # Invoke the agent with config
        final_state = app.invoke(
            {"messages": [{"role": "user", "content": query}]},
            config=config
        )
        return final_state["messages"][-1].content
    except Exception as e:
        return f"An error occurred while processing your query: {str(e)}\n\nPlease try a more specific query or provide an IP address directly."

def main():
    """Main function to run the script."""
    print("CVE Vulnerability Scanner")
    print("-----------------------")

    # Get credentials
    credentials = get_credentials()

    # Setup ArangoDB and load CVE dataset
    sys_db, G, G_adb, arango_graph = setup_arangodb(credentials)

    # Check if nmap is available
    print(f"Nmap version: {get_nmap_version()}")

    # Get query from user
    query = input("Enter IP to scan or query: ")

    # Query the graph
    result = query_graph(query, credentials, sys_db, G, G_adb, arango_graph)
    print("\nResult:")
    print(result)

if __name__ == "__main__":
    main()

import nmap3
import re
from google.colab import userdata

@tool
def return_nmap_scan(query: str):
    """
    This tool extracts an IP address from the query, performs an Nmap version scan,
    and fetches known vulnerabilities from the ArangoDB dataset.
    """
    # Extract the IP address from the query
    ip_match = re.search(r"\b(?:\d{1,3}\.){3}\d{1,3}\b", query)
    if not ip_match:
        return "Could not find a valid IP address in the query."

    ip_address = ip_match.group(0)

    # Prevent infinite recursion by checking if this function is being called again
    if "Retrieve all known vulnerabilities" in query:
        return "Avoiding recursion: A vulnerability lookup was already performed."

    # Perform Nmap version scan
    nmap = nmap3.Nmap()
    scan_results = nmap.nmap_version_detection(ip_address)

    if not scan_results or ip_address not in scan_results:
        return f"No scan results found for {ip_address}."

    # Extract detected services and versions
    detected_services = []
    for port, details in scan_results[ip_address].items():
        service_name = details.get("service", "")
        version = details.get("version", "")
        if service_name:
            detected_services.append((service_name, version))

    if not detected_services:
        return f"Nmap scan completed, but no detectable services were found on {ip_address}."

    # Query ArangoDB for vulnerabilities
    vulnerabilities = []
    for service, version in detected_services:
        if version:
            query = f"""
                Retrieve all known vulnerabilities (CVEs) related to the service '{service}'
                with version '{version}' from the ArangoDB graph.
                Return critical details such as CVE IDs, severity, and descriptions.
            """
        else:
            query = f"""
                Retrieve all known vulnerabilities (CVEs) related to the service '{service}'
                from the ArangoDB graph. Return critical details such as CVE IDs, severity,
                and descriptions.
            """

        vuln_data = text_to_aql_to_text(query)  # Fetch from ArangoDB
        if vuln_data and vuln_data != "No results found":
            vulnerabilities.append({service: vuln_data})

    # Format the response
    if vulnerabilities:
        return {
            "ip_address": ip_address,
            "detected_services": detected_services,
            "vulnerabilities": vulnerabilities
        }
    else:
        return f"No known vulnerabilities found for detected services on {ip_address}."

@tool
def text_to_aql_to_text(query: str):
    """This tool translates a Natural Language Query into AQL, executes
    the query, and translates the result back into Natural Language.
    """

    GROQ_API_KEY = userdata.get('GROQ_API_KEY')
    llm = ChatGroq(temperature=0, groq_api_key=GROQ_API_KEY, model="llama-3.3-70b-versatile")
    chain = ArangoGraphQAChain.from_llm(
    	llm=llm,
    	graph=arango_graph,
    	verbose=True,
        allow_dangerous_requests=True
    )

    result = chain.invoke(query)

    if "result" in result and result["result"]:
        return str(result["result"])
    else:
        return "No results found"

@tool
def text_to_nx_algorithm_to_text(query):
    """This tool runs a NetworkX algorithm on an ArangoDB Graph and
    translates the results back into Natural Language.
    """
    GROQ_API_KEY = userdata.get('GROQ_API_KEY')
    llm = ChatGroq(temperature=0, groq_api_key=GROQ_API_KEY, model="llama-3.3-70b-versatile")

    print("1) Generating NetworkX code")

    text_to_nx = llm.invoke(f"""
    I have a NetworkX Graph called `G_adb`. It has the following schema: {arango_graph.schema}

    My query is: {query}.

    Generate the Python Code required to answer the query using `G_adb`.

    Ensure that:
    - The correct NetworkX algorithm is used.
    - The code is precise and efficient.
    - The final result is stored in a variable named `FINAL_RESULT`.
    - `FINAL_RESULT` should be short and concise.

    Provide only the Python code, without explanations.

    Your code:
    """).content

    text_to_nx_cleaned = re.sub(r"^```python\n|```$", "", text_to_nx, flags=re.MULTILINE).strip()

    print('-'*10)
    print(text_to_nx_cleaned)
    print('-'*10)

    print("\n2) Executing NetworkX code")
    global_vars = {"G_adb": G_adb, "nx": nx}
    local_vars = {}

    try:
        exec(text_to_nx_cleaned, global_vars, local_vars)
        text_to_nx_final = text_to_nx
    except Exception as e:
        print(f"EXEC ERROR: {e}")
        return f"EXEC ERROR: {e}"

    FINAL_RESULT = local_vars["FINAL_RESULT"]
    print('-'*10)
    print(f"FINAL_RESULT: {FINAL_RESULT}")
    print('-'*10)

    print("3) Formulating final answer")

    nx_to_text = llm.invoke(f"""
        I have executed a NetworkX algorithm to answer the following query:

        {query}

        The result, stored in `FINAL_RESULT`, is: {FINAL_RESULT}.

        Generate a short and clear explanation of the result.

        Your response:
    """).content

    return nx_to_text

tools = [text_to_aql_to_text, text_to_nx_algorithm_to_text, return_nmap_scan]

def query_graph(query):
    """
    Queries the AI-powered graph, using available tools to process the query.
    """

    # Debugging log: print query input
    print(f"Querying graph with: {query}")
    print(f"Tools available: {tools}")

    GROQ_API_KEY = userdata.get('GROQ_API_KEY')
    llm = ChatGroq(temperature=0, groq_api_key=GROQ_API_KEY, model="llama-3.3-70b-versatile")
    app = create_react_agent(llm, tools)

    try:
        # Increase recursion limit to avoid premature termination
        final_state = app.invoke(
            {"messages": [{"role": "user", "content": query}]},
            config={"recursion_limit": 100}  # Increased limit
        )
        response = final_state["messages"][-1].content
    except Exception as e:
        print(f"ERROR in query_graph: {e}")
        response = f"An error occurred: {e}"

    # Debugging log: print final response
    print(f"Final state response: {response}")

    return response


# Test run
query_graph("Scan 44.228.249.3 for vulnerabilities")

